<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<title>The Programmer's Perspective</title>
<link rel="STYLESHEET" href="base.css" type="text/css" title="base.css">
</head>
<body>
<h1>Yo!</h1>
<hr />
<p class="navbar">
<a href="SiteMap.html">Sitemap</a> || <a href="index.html">PageTemplate</a>
 / The Programmer's Perspective</p>
<h1>The Programmer's Perspective</h1>
<hr />

<table width='100%' border='0'><tr>
<td><p>&lt;- <a href='designer.html'>The Designer&#8217;s Perspective</a></p>
</td>
<td align='right'><p><a href='version2.html'>PageTemplate Version 2</a>- &gt;</p>
</td>
</tr></table>

	<h2>Getting Started</h2>


	<p>Before you dig into the code, you might want to take a look at
the <a href="products/pagetemplate/designer.html">designer</a> perspective of PageTemplate.</p>


	<h2>Using PageTemplate In Your Ruby Code</h2>


	<p>This is a <em>very</em> quick overview, because I have realized lately that <em>more</em>
documentation isn&#8217;t necessarily <em>better</em> documentation. <a href="contact">Send me</a> 
any questions you have, or clarifications you&#8217;d like to see, and I will be 
happy to incorporate them into future revisions of this article.</p>


	<p>First, of course, you&#8217;ll want to <a href="products/pagetemplate/install.html">install</a> the PageTemplate package. 
Once that&#8217;s done, <code>require</code> the package.</p>


<pre class="code">
require "PageTemplate" 
</pre>

	<p>You&#8217;ll need a PageTemplate object to hold values and parse template files.</p>


<pre class="code">
template = PageTemplate.new()
</pre>

	<p>At some point, you will want the PageTemplate object to load a
template text file, bristling with directives. The template file should
be readable by the script, and the path must be either absolute
or relative to the script&#8217;s working directory.</p>


<pre class="code">
template.load("/var/www/templates/template.txt")
</pre>

	<p>To assign a value for use by PageTemplate, use hash-style
assignment, with the name to be used by the template as the key,
and the value assigned as &#8230; well &#8230; the value. The only rule is
that the value must evaluate to a String (either it <em>is</em> a
String or it has a <code>to_s</code> method). Page designers
would probably be grateful if the key was a string, too. Much
easier to type it into a text template that way.</p>


<pre class="code">
template["title"] = "My PageTemplate Script" 
</pre>

	<p>The easiest way to handle flags used in <code>if</code> directives
is to take advantage of Ruby&#8217;s boolean values.</p>


<pre class="code">
template["flag"] = true
template["otherflag"] = false
</pre>

	<p>You can use the truth of a regular variable or loop variable in
an <code>if</code> directive, but remember that Ruby is more specific
about <code>false</code> than other languages you might be used to.
For example, the number zero is not false, it&#8217;s just zero. Same
with empty strings. If you want a variable to be interpreted as 
<code>false</code>, you should explicitly set it.</p>


	<p>PageTemplate uses arrays of objects for lists.  Each object provides a local 
namespace which lasts only for the current iteration through the chunk of 
content. Otherwise, you&#8217;d have to manually set loop variables, and I don&#8217;t 
like that idea!</p>


	<p>The classic approach is to borrow from <span class="caps">HTML</span>::Template and use a list of hashes 
for your namespaces.</p>


<pre class="code">
listing = [
 { "name" =&gt; "Swordfishtrombones", "artist" =&gt; "Tom Waits" },
 { "name" =&gt; "Dirt Track Date", "artist" =&gt; "Southern Culture On The Skids"},
 { "name" =&gt; "Amnesiac", "artist" =&gt; "Radiohead" }
]

template["albums"] = listing
</pre>

	<p>What about nested lists? They are handled the same way. One of
the keys in your item hash points to another array of hashes, which
will be used for the inner loop.</p>


<pre class="code">
favorites = [
  { "topic"  =&gt; "Interesting Comic Books",
    "items"    =&gt; [
    { "title"   =&gt; "Dropsie Avenue", 
      "creator" =&gt; "Will Eisner"},
    { "title"   =&gt; "Cerebus", 
      "creator" =&gt; "Dave Sim"},
    { "title"   =&gt; "Jar Of Fools", 
      "creator" =&gt; "Jason Lutes"}
  ]},
  { "topic"  =&gt; "Favorite Albums",
    "items"    =&gt; [
    { "title"   =&gt; "Amnesiac", 
      "creator" =&gt; "Radiohead"},
    { "title"   =&gt; "The Moon and Antarctica", 
      "creator" =&gt; "Modest Mouse"},
    { "title"   =&gt; "Dirt Track Date", 
      "creator" =&gt; "Southern Culture On The Skids"},
    { "title"   =&gt; "My Motor", 
      "creator" =&gt; "Dorkweed"},
    { "title"   =&gt; "Swordfishtrombones", 
      "creator" =&gt; "Tom Waits"}
  ]}
]
</pre>

	<p>Using objects in a list requires a little more research, but it&#8217;s
still a practical solution. Say you&#8217;re trying to figure out how
to use PageTemplate in an image gallery.  You might have an Image class with 
accessors that look something like this:</p>


<pre class="code">
class Image
  attr_reader :url, :height, :width, :caption
end
</pre>

	<p>You can build your template armed with this knowledge.</p>


<pre>
[%in images%]
&lt;td&gt;
  &lt;img src="[%var url%]" height="[%var height%]" width="[%var width%]" alt="[%var caption%]" /&gt;&lt;br /&gt;
  [%var caption%]
&lt;/td&gt;
[%endin%]
</pre>

Then, rather than waste precious minutes altering class
<code>Image</code> to respond to hash-based access, you can 
assign a list of <code>Image</code> objects to the template list.

<pre class="code">
gallery = Gallery.new()
# ...
galleryPage['images'] = gallery.current.images
</pre>

	<p>This approach definitely encourages maintaining a consistent 
interface. I wouldn&#8217;t want to go altering my template files (or 
telling the designer to alter her files) every time I get a bright
idea for how <code>Image</code> should work.</p>


You can also refer to public methods of the object in your
template, but that&#8217;s still a bit shaky. The methods have to accept
calls with no arguments or blocks (Ex: 
<code>image.thumbnail()</code> would be referenced as 
<code>[%var thumbnail%]</code>).

	<p>Once you&#8217;ve told your PageTemplate object which file to load and
what values to remember, you&#8217;ll probably want to display the
neat custom page.</p>


<pre class="code">
output = template.output
print output
</pre>

	<p>Of course, if you do things this way you&#8217;ll have to remember all of
the <acronym title="Hypertext Transfer Protocol"><span class="caps">HTTP</span></acronym>
header information. Life will be much easier for you if you just use
the functionality provided by the standard <span class="caps">CGI</span> module for ruby.</p>


<pre class="code">
cgi.out { template.output }
</pre>

	<h3>Including Files</h3>


	<p>PageTemplate lets you insert text from other files. Even better: PageTemplate
will parse those files as templates, using your current Namespace. The only
issue that you must be aware of as a developer is the search path used by
PageTemplate.</p>


	<ul>
	<li>Variable includes</li>
		<li>Filenames, relative to the search path.</li>
	</ul>


	<p>Now I will explain each of these.</p>


	<h4>Variable Includes</h4>


<pre>[%include weather%]</pre>

<pre class="code">
weather = some_file_path_returned_by_a_method()
template['weather'] = weather
</pre>

	<h4>Filenames</h4>


<pre>[%include weather.html%]</pre>

	<p>The include path defaults to the script&#8217;s working directory (accessed via
<code>Dir.getwd</code>). You can add additional paths if this isn&#8217;t good enough
for you.</p>


<pre class="code">
template = PageTemplate.new(
  'include_paths' =&gt; ["/var/www/templates"]
)
</pre>

	<p><code>template</code> now has an include path of the script&#8217;s working directory and <code>/var/www/templates/</code>.
The include path Array is accessible via the <code>paths</code> accessor.</p>


<pre class="code">
template = PageTemplate.new()
template.paths.source += [ 'templates/blue', 'templates/alpha' ]
</pre>

	<h3>Digging Deeper</h3>


	<p>The stuff covered in this tutorial should remain pretty consistent
through future versions. If you&#8217;re curious to see inside 
PageTemplate.rb, though, you will definitely want to go over the
<a href="products/pagetemplate/doc/">reference pages</a>. It describes PageTemplate and the classes that back it 
up. Be warned, though: anything not described in this page is definitely 
subject to change, so your clever hack might be useless with the next release. 
That never stopped me, though. Go, have fun!</p>


	<h3>Creating Your Own Syntax</h3>


	<p>Syntax glossaries are high on the list of things I want to change,
so I&#8217;m not going to write an extensive tutorial on creating your
own custom syntax yet. For now, use the <a href="products/pagetemplate/doc/">reference pages</a> as a guideline.</p><hr />

<p class="navbar">
<a href="SiteMap.html">Sitemap</a> || <a href="index.html">PageTemplate</a>
 / The Programmer's Perspective</p>

<h1>Yo!</h1>
<hr />
</body>
</html>
